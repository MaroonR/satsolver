#!/usr/bin/python3

#open file and read data into a list
import os
import random
import sys
sys.setrecursionlimit(3000)
fn = os.path.join(os.path.dirname(__file__), 'tests/10.40.160707067.cnf')

with open(fn) as f:
    lines = f.readlines()

clauses = []
clause = []
var_count = 0
clause_count = 0
x = 0
varflag = 0
token = ""
token2 = ""


for i in lines:
    if(i[0] == 'c' or i[0] == 'p'):
        if(i[0] == 'p'):
            for j in i:
                if(j == ' '):
                    varflag+=1
                elif(varflag >= 2 and varflag < 3):
                    print("2")
                    token+=(j)
                elif(varflag >= 3 and j != '\n'):
                    token2+=(j)
            var_count = int(token)
            clause_count = int(token2)
    else:
        for j in i:
            if(j == '-'):
                negflag = 1;
            elif(j == ' 'or j == '\n'):
                continue
            else:
                if(negflag == 1):
                    x = int(j)
                    clause.append(-x)
                    negflag = 0
                else:
                    clause.append(int(j))

        clauses.append(clause);
        clause = []

for i in clauses:
    print(i)

print("Number of variables: " + str(var_count))
print("Number of clauses: " + str(clause_count))

f.close()

def createCandidate(var_count):
    result = []
    for i in range(0, var_count):
        result.append(random.randrange(2))
    return result

def checkSat(candidate, clause):
    """this function checks for satisfiablity of a single CNF"""

    var1 = clause[0];
    var2 = clause[1];
    var3 = clause[2];

    vX = candidate[abs(var1)]
    vY = candidate[abs(var2)]
    vZ = candidate[abs(var3)]

    if(var1 < 0):
        vX = not vX
    if(var2 < 0):
        vY = not vY
    if(var3 < 0):
        vZ = not vZ

    return (vX | vY | vZ)

def satScore(candidate, clauses):
    result = []
    for i in clauses:
        if(checkSat(candidate, i) == 1):
            result.append(1)
        else:
            result.append(0)
    return result

def walksat(var_count, clause_count, clauses, candidate, depth, best):
    """This function implements the walksat algorithm on the
    given sat problem"""
    print("Starting with new candidate: " + str(candidate) + " " + str(sum(satScore(candidate, clauses))))
    if(sum(satScore(candidate, clauses)) == clause_count):
        #base case
        print("Solution satisfies all CNF's")
        for i in candidate:
            print(i, end="")
        return candidate

    if(depth > 2500):
        #base case #2
        print("walksat not finding a solution... :(")
        print(depth)
        print("best solution satisfied: " + str(best))
        return -1
    #test candidate against clauses:
    score = 0
    satfd = satScore(candidate, clauses)

    ## choose a failed cnf at random
    choices = []
    count = 0;
    # get our choices
    for i in satfd:
        if(i == 0):
            choices.append(count)
        count+=1
    # choose a random choice
    choice = random.randrange(len(choices))

    # choices[choice] == our chosen cnf

    # we now need to pick a variable from our chosen cnf that will
    # yield the smallest number of cnfs that move from sat'd to unsat'd
    tc1 = candidate[:]
    tc2 = candidate[:]
    tc3 = candidate[:]

    var1 = clauses[choices[choice]][0]
    var2 = clauses[choices[choice]][1]
    var3 = clauses[choices[choice]][2]

    tc1[var1] = not tc1[var1]
    tc2[var2] = not tc2[var2]
    tc3[var3] = not tc3[var3]

    score1 = satScore(tc1, clauses)
    print("Option 1: " + str(score1) + " " + str(sum(score1)))
    score2 = satScore(tc2, clauses)
    print("Option 2: " + str(score2) + " " + str(sum(score2)))
    score3 = satScore(tc3, clauses)
    print("Option 3: " + str(score3) + " " + str(sum(score3)))


    # score1-3 holds the passed cnfs for each test candidate. sum(score#) holds the heuristic score
    # Now lets choose the largest of these and let it reiterate through the function again

    if(score1 > score2):
        if(sum(score1) > sum(score3)):
            curr_best = sum(score1)
            if(curr_best > best):
                best = curr_best
            print("Candidate: " + str(tc1))
            print("Candidate Score: " + str(sum(score1)))
            current_candidate = walksat(var_count, clause_count, clauses, tc1[:], depth+1, best)
        elif(sum(score3) > sum(score1)):
            curr_best = sum(score3)
            if(curr_best > best):
                best = curr_best
            print("Candidate: " + str(tc3))
            print("Candidate Score: " + str(sum(score3)))
            current_candidate = walksat(var_count, clause_count, clauses, tc3[:], depth+1, best)
        elif(sum(score3) <= sum(score1)):
            curr_best = sum(score1)
            if(curr_best > best):
                best = curr_best
            print("Candidate Score: " + str(sum(score1)))
            current_candidate = walksat(var_count, clause_count, clauses, tc1[:], depth+1, best)
    else:
        if(sum(score2) > sum(score3)):
            curr_best = sum(score2)
            if(curr_best > best):
                best = curr_best
            print("Candidate: " + str(tc2))
            print("Candidate Score: " + str(sum(score2)))
            current_candidate = walksat(var_count, clause_count, clauses, tc2[:], depth+1, best)
        elif(sum(score2) >= sum(score3)):
            curr_best = sum(score2)
            if(curr_best > best):
                best = curr_best
            print("Candidate: " + str(tc2))
            print("Candidate Score: " + str(sum(score2)))
            current_candidate = walksat(var_count, clause_count, clauses, tc2[:], depth+1, best)
        else:
            curr_best = sum(score3)
            if(curr_best > best):
                best = curr_best
            print("Candidate: " + str(tc3))
            print("Candidate Score: " + str(sum(score3)))
            current_candidate = walksat(var_count, clause_count, clauses, tc3[:], depth+1, best)

    return current_candidate

def genetic(var_count, clause_count, clauses):

    def mutate(candidate):
        #select a random variable and flip it?
        mutated_candidate = list(candidate)
        mutate_pos = random.randrange(10)
        print(mutate_pos)
        print(len(mutated_candidate))
        mutated_candidate[mutate_pos] = not mutated_candidate[mutate_pos]
        return mutated_candidate


    POOL_SIZE = 200
    candidates = []
    scores = []

    # create a pool of candidates
    # create scoreboard for candidates
    for i in range(POOL_SIZE):
        candidate = createCandidate(var_count)
        candidates.append(candidate)
        scores.append(sum(satScore(candidate, clauses)))

    for i in range(POOL_SIZE):
        print(str(candidates[i]), end=' ')
        print(str(scores[i]))

    while(1):
        #find the 90th percentile and cull the result
        scores_sorted = sorted(scores[:])
        # 90th percentile of POOL_SIZE = len(poolsize) * 9/10
        wall = scores_sorted[round(len(scores_sorted) * 9/10)]
        ns = []
        for i in range(POOL_SIZE):
            if (scores[i] < wall):
                ns.append(i)
        ns_sorted = sorted(ns, reverse=True)
        #let natural selection do its work
        for i in ns_sorted:
            del scores[i]
            del candidates[i]

        len(candidates)
        while(len(candidates) != POOL_SIZE):
            candidate_to_be_mutated = random.randrange(len(candidates))
            mutated_candidate = mutate(candidates[candidate_to_be_mutated])
            candidates.append(mutated_candidate)
            scores.append(sum(satScore(mutated_candidate, clauses)))

        for i in range(POOL_SIZE):
            print(str(candidates[i]), end=' ')
            print(str(scores[i]))
            if(scores[i] == 40):
                #found a winning candidate
                print("Winning Candidate")
                print(candidates[i], end= ' ')
                print(scores[i])
                return















#walksat(var_count, clause_count, clauses, createCandidate(var_count), 0, 0)

genetic(var_count, clause_count, clauses)
